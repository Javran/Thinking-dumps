# Persistence

* Functional data structure does not destroy the existing version,
  instead, it creates a new version of it.

* Since nodes are not mutated, they can be shared between many versions of the same
  data structure.

## Lists (2.1)

Basic operations:

* `cons h t` (or `h : t`) prepends `h` in front of `t`
* `head xs` gets the head of a non-empty list
* `tail xs` gets the tail of a non-empty list
* `empty` (or `[]`) creates an empty list
* `isEmpty xs` tests emptiness of a list `xs`

**List concatenation `(++)`** is usually implemented by destructing its first argument:

```haskell
(++) xs ys = case xs of
  [] -> ys
  (a:as) -> a : (++) as ys
```

One observation of this implementation is that while `xs` is destructed
and traversed (doing so causes the $O(n)$ time complexity),
`ys` is not touched at all. say if `zs = xs ++ ys`,
then `ys` will be shared to `zs` as its "subtree".

**List update function `update`** can be implemented in the following way:

```haskell
update [] i y = error "subscript"
update (x:xs) 0 y = y : xs
update (x:xs) i y = x : update xs (i-1) y
```

So `update` does not destroy the old list, instead, it copies all nodes
on the path from root to the one we want to update, but rest of
the nodes are shared between old and new one.

## Binary Search Trees (2.2)

A BST is a binary tree with the following property:

- for any node in the tree:
    - if it is a non-leaf node, then it contains an element `v`
    - all elements of its left subtree are less than `v`
    - all elements of its right subtree are greater than `v`

Notes:

* This implies elements must support total order.
* No duplicate elements: suppose we want to insert
  something that already exists, it either inserts
  recursively to left or right node, or dropped because
  it is equal to the current node.

In addition to all operations supported by binary trees, it has two operations:

* `member v set`: tests if `v` is a member of `set`.
* `insert v set`: inserts `v` into `set`.

Both membership test and insertion are done by traversing down the tree,
comparing nodes in the way to decide either going recursively to one of the subtrees
or stop if an element is found.

## Red-Black Trees (2.3)

A red-black tree is a binary search tree that keeps the tree approximately balanced.

In the book, a red-black tree has the following properties:

* No red node has a red child
* Every path from the root to an empty node contains the same number of black nodes.

In addition to this, other books might state few more properties:

* Every node is colored either red or black
* Root node is black

Notes:

* My intuition about red-black trees: consider a red-black tree in which all nodes are black,
  this tree must be a complete and full binary tree because of the constraint of black depth.
  Now we can insert red nodes to make the tree looks unbalanced. But red nodes cannot have red children,
  so the total amount of red nodes allowed to be inserted in this red-black tree is somehow bounded.
  (by "insert" I mean visually adding some on the path from root to null, not in a sense of inserting into
  a binary search tree)
