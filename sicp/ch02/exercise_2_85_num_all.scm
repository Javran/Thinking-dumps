(define (tagged tag f)
  (lambda args
    (attach-tag tag (apply f args))))

(define (install-integer-package)
  (define (make-integer x)
    (if (integer? x)
      (attach-tag 'integer x)
      (error "MAKE-INTEGER: not an integer" x)))

  (define (integer->rational x)
    ((get 'make 'rational) (contents x) 1))

  (put 'make 'integer make-integer)
  (put 'add '(integer integer) (tagged 'integer +))
  (put 'sub '(integer integer) (tagged 'integer -))
  (put 'raise '(integer) (lambda (x)
                           ((get 'make 'rational) x 1)))
  (put '=zero? '(integer) (lambda (x) (= x 0)))
  'done)

(define (install-rational-package)
  (define numer car)
  (define denom cdr)
  (define (make-rat n d)
    (let ((g (gcd n d)))
      (cons (/ n g)
            (/ d g))))
  (define (add-rat x y)
    (make-rat (+ (* (numer x) (denom y))
                 (* (numer y) (denom x)))
              (* (denom x) (denom y))))
  (define (neg-rat x)
    (make-rat (- (numer x))
              (denom x)))
  (define (sub-rat x y)
    (add-rat x (neg-rat y)))

  (put 'make 'rational (tagged 'rational make-rat))
  (put 'add '(rational rational) (tagged 'rational add-rat))
  (put 'sub '(rational rational) (tagged 'rational sub-rat))

  (put 'raise '(rational)
       (lambda (r)
         ((get 'make 'real) (/ (numer r)
                               (denom r)))))
  (put '=zero? '(rational)
       (lambda (r) (= (numer r) 0)))
  (put 'project '(rational)
       (lambda (r)
         ((get 'make 'integer) (round (/ (numer r)
                                         (denom r))))))
  'done)

(define (install-real-package)

  (define (=zero? x) (< (abs x) eps))
  (define (real->rational target)
    (define make-rational (get 'make 'rational))
    (define (close-to-rational n d)
      (if (< (abs (- (/ (round n) (round d)) target)) eps)
        (make-rational (round n) (round d))
        (close-to-rational (* 10 n) (* 10 d))))
    (close-to-rational target 1))

  (put 'make 'real (tagged 'real identity))
  (put 'add '(real real) (tagged 'real +))
  (put 'sub '(real real) (tagged 'real -))
  (put 'raise '(real) (lambda (r)
                        ((get 'make 'complex) r 0)))
  (put '=zero? '(real) =zero?)
  (put 'project '(real) real->rational)
  'done)

(define (install-complex-package)
  (define make-complex cons)
  (define real-part car)
  (define imag-part cdr)
  (define (magnitude x)
    (let ((a (real-part x))
          (b (imag-part x)))
      (sqrt (+ (square a) (square b)))))
  (define (=zero? x)
    (< (magnitude x) eps))

  (define (add a b)
    (make-complex
      (+ (real-part a) (real-part b))
      (+ (imag-part a) (imag-part b))))

  (define (neg x)
    (make-complex (- (real-part x))
                  (- (imag-part x))))

  (define (sub a b)
    (add a (neg b)))

  (put 'make 'complex (tagged 'complex make-complex))
  (put 'add '(complex complex) (tagged 'complex add))
  (put 'sub '(complex complex) (tagged 'complex sub))
  (put '=zero? '(complex) =zero?)
  (put 'project '(complex) (lambda (x)
                             ((get 'make 'real) (real-part x))))
  'done)
