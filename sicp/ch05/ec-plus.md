# Explicit Control Evaluator Plus (ec-plus.scm)

`ec-plus.scm` implements an extension of explicit control evalator
described in 5.5.7 of SICP. Some tweaks are applied to make it looks more decent.
This document describes the changes I made together with some justification.

Potentially all the following exercises (a.k.a. `exercises >= 5.45`) will
be based on this version of implementation.

## Addressing inconsistent strategy of argument evaluation

In the original design, there is an inconsistency between
our evaluator and the instruction sequence generated by our compiler:
when dealing with function applications, our compiler tries to compile code
that evaluate operands from right to left whereas our evaluator evaluates
operands from left to right.

If the evaluation of operands do not mutate things or have other kinds of side effects,
then we are fine. But if it is not the case, then the result will be inconsistent.

The following scheme code demonstrates the difference:

```scheme
(begin
  (define x 1)
  (let ((a (begin
             (set! x (+ x 10))
             x))
        (b (begin
             (set! x (* x 2))
             x)))
    (cons a b)))
```

Note that `let`-form is actually a syntactic sugar for function application,
the order of evaluating `a` and `b` varies depending on the strategy of evaluation.

In some scheme implementations like `racket` or `guile`, the code above
evaluates to `(11 . 22)` because `a` is evaluated first. By evaluating `a`
first, `x` is set to `11`. And then `b` gets evaluated with `x` being further
updated to `22`.

In some other implementation like `mit-scheme`, however, the arguments
are evaluated from right to left. If `b` gets evaluated first, by using
a similar way of reasoning, we will find the result to be `(12 . 2)`.

This inconsistency might lead to confusions and troubles so we really want to solve it.

Thanks to our answer to exercise 5.36,
we have a patch (i.e.`exercise_5_36_compiler.scm`) that makes the compiler
generate code for function application that evaluates arguments from left
to right. And this patch solves the inconsistency issue.

## Keeping track of the top-level environment


## We are still cheating a little bit


## Additive assembling


## Getting rid of initialization hacks


