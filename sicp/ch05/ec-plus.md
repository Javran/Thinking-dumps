# Explicit Control Evaluator Plus (ec-plus.scm)

`ec-plus.scm` implements an extension of explicit control evalator
described in 5.5.7 of SICP. Some tweaks are applied to make it more decent.
This document describes changes I made together with some justification.

Potentially all the following exercises (i.e. `exercises >= 5.45`) will
be based on this version of implementation.

## Addressing inconsistent strategy of argument evaluation

In the original design, there is an inconsistency between
our evaluator and the instruction sequence generated by our compiler:
when dealing with function applications, our compiler tries to compile codes
that evaluate operands from right to left whereas our evaluator evaluates
operands from left to right.

If the evaluation of operands do not mutate things or have other kinds of side effects,
then we are fine. But if it is not the case, then the result will be inconsistent.

For example consider the following scheme code:

```scheme
(begin
  (define x 1)
  (let ((a (begin
             (set! x (+ x 10))
             x))
        (b (begin
             (set! x (* x 2))
             x)))
    (cons a b)))
```

Note that `let`-form is actually a syntactic sugar for function application,
the order of evaluating `a` and `b` varies depending on the strategy of evaluation.

In some scheme implementations like `racket` or `guile`, the code above
evaluates to `(11 . 22)` because `a` is evaluated first. By evaluating `a`
first, `x` is set to `11`. And then `b` gets evaluated with `x` being further
updated to `22`.

In some other implementation like `mit-scheme`, however, the arguments
are evaluated from right to left. If `b` gets evaluated first, by using
a similar way of reasoning, we will find the result to be `(12 . 2)`.

This inconsistency might lead to confusions and troubles so we really want to solve it.

Thanks to our answer to exercise 5.36,
we have a patch (i.e.`exercise_5_36_compiler.scm`) that makes the compiler
generate code for function application that evaluates arguments from left
to right. And this patch solves the inconsistency issue.

## Keeping track of the top-level environment

Top-level environment includes bindings for variables directly available
to the user. In the book they use the term "global environment" but they are
the same thing.

In the book the definition for `get-global-environment` is the following:

```scheme
(define the-global-environment (setup-environment))
(define (get-global-environment) the-global-environment)
```

This defnition is bad because if we are using multiple instances of machines,
their modifications to their own global environment are visible to each other.

Since our simulator is just an object with some fields, we can easily extend
the structure to make it also store the top-level environment as well.
Since the environment object is stored somewhere within the machine,
it will be fine to have multiple machines running at the same time,
and their environment will be independent of each other.

Of course a little more work needs to be done when creating the machine,
namely we need to initialize the environment and put it in the machine.

## We are still cheating a little bit

No actual modification is done on this part, I just want to point out some concerns
about the machine we are implementing.

It is true that as we go through SICP, we are relying on fewer and fewer
operations and types, but remember that our `pc` register and `continue` register
are still storing some complex structures, namely the assembled sequence
of instructions.

In real life we might need some machanisms to store the assembled
sequence of instructions somewhere other than machine registers.
To make it still possible for registers to refer to places in the instruction sequence,
registers can keep integers as indices to certain instruction location in the machine.

Moreover, if we want to make it possible to compile code in the evaluator,
we also need to find a way to compile, assemble the code and put the resulting
data into the machine and be able to transfer control to it and back from it.

## Additive assembling

This is actually a problem with our implementation of simulator,
which might get in the way if we want to do assembling more than once
for a single machine.

Different from the legacy simulator, our simulator assumes the user will
assemble instruction sequence no more than once. Therefore our `assemble`
procedure does some extra checks on the instruction sequence being assembled
(because we are receiving the full sequence of instructions, more checks
can be done to have more confidence about its correctness).
Instead of appending the resulting to the existing sequence of assembled
instructions, our implementation overwrites the previous stored
assembled sequence of instructions.

Therefore we implements a patch to make the implementation a little bit
closer to the one implemented in the book: if you apply the patch
`simu_additive-assemble_patch.scm`, you will get an "additive" assemble
so that the resulting sequence of assembled instructions get appended
to the existing one instead of overwriting it. Some checks are still there,
but instead of checking it once for all, every time when a new
sequence of instruction comes, the jump-table gets checked to ensure
that every labels are unique.

Note that this patch is not actually necessary if you only need to
assemble the code once. But because we might need to compile, assemble
and insert things at run time, this patch is potentially useful.

## No conflicting labels


## Getting rid of initialization hacks


